% Generated by roxygen2 (4.1.1): do not edit by hand
% Please edit documentation in R/join-ffdf.R
\name{join.tbl_ffdf}
\alias{anti_join.ffdf}
\alias{inner_join.ffdf}
\alias{join.tbl_ffdf}
\alias{left_join.ffdf}
\alias{semi_join.ffdf}
\title{Join ffdf tbls.}
\usage{
\method{inner_join}{ffdf}(x, y, by = NULL, copy = FALSE, ...)

\method{left_join}{ffdf}(x, y, by = NULL, copy = FALSE, ...)

\method{semi_join}{ffdf}(x, y, by = NULL, ...)

\method{anti_join}{ffdf}(x, y, by = NULL, ...)
}
\arguments{
\item{x,y}{tbls to join}

\item{by}{a character vector of variables to join by.  If \code{NULL}, the
  default, \code{join} will do a natural join, using all variables with
  common names across the two tables. A message lists the variables so
  that you can check they're right.

  To join by different variables on x and y use a named vector.
  For example, \code{by = c("a" = "b")} will match \code{x.a} to
  \code{y.b}.}

\item{copy}{If \code{x} and \code{y} are not from the same data source,
and \code{copy} is \code{TRUE}, then \code{y} will be copied into the
same src as \code{x}.  This allows you to join tables across srcs, but
it is a potentially expensive operation so you must opt into it.}

\item{...}{Included for compatibility with generic; otherwise ignored.}
}
\description{
See \code{\link[dplyr]{join}} for a description of the general purpose of the
functions.
}
\examples{
if (require(Lahman)){
data("Batting", package = "Lahman")
data("Master", package = "Lahman")

batting_ffdf <- tbl_ffdf(Batting)
person_ffdf <- tbl_ffdf(Master)

# Inner join: match batting and person data
inner_join(batting_ffdf, person_ffdf)

# Left join: keep batting data even if person missing
left_join(batting_ffdf, person_ffdf)

# Semi-join: find batting data for top 4 teams, 2010:2012
grid <- expand.grid(
  teamID = c("WAS", "ATL", "PHI", "NYA"),
  yearID = 2010:2012)
top4 <- semi_join(batting_ffdf, grid, copy = TRUE)

# Anti-join: find batting data with out player data
anti_join(batting_ffdf, person_ffdf)
}
}

